// AUTO BEAT MARKER — Enhanced Production v2.0 (Brazilian Phonk-aware)
// Fully backward-compatible UI (keeps labels, controls and layout identical).
// Improvements: Robust error handling, optimized loops, improved smoothing,
// safer file I/O for presets, clearer logging/status, protection against huge keyframe sets.
// --- Added: Brazilian Phonk-specific multi-band detection heuristics, adaptive thresholds,
// high/low-band peak detectors, tempo bias toward 120-160 BPM and half-time handling.

/* NOTE:
   - All original function names, variables and UI elements are preserved.
   - Additional detection logic is implemented with minimal invasive changes and
     conditional fallbacks so the script continues to work for other genres.
*/

(function (thisObj) {
    // ---- Config ----
    var SCRIPT_NAME = "AUTO BEAT MARKER PRO";
    var MAX_KEYFRAMES = 12000; // safety limit for user confirmation
    var PRESET_FILENAME = "autoBeatPresets.json";

    // ---- Utilities: safe logging/status ----
    function safeAlert(msg) {
        try { alert(msg); } catch (e) {} // never blow up UI
    }
    function setStatus(s) {
        try { status.text = String(s); } catch (e) {}
    }
    function clamp(v, min, max) { return (v < min) ? min : (v > max) ? max : v; }

    // ---- Preset file helpers (safe) ----
    function getPresetFile() {
        try {
            var f = new File($.fileName);
            return new File(f.path + "/" + PRESET_FILENAME);
        } catch (e) {
            return null;
        }
    }

    function loadPresets() {
        try {
            var pf = getPresetFile();
            if (!pf || !pf.exists) return {};
            if (!pf.open("r")) return {};
            var content = pf.read();
            pf.close();
            if (!content) return {};
            try { return JSON.parse(content); } catch (e) { return {}; }
        } catch (e) {
            return {};
        }
    }

    function savePresets(obj) {
        try {
            var pf = getPresetFile();
            if (!pf) return false;
            if (!pf.open("w")) return false;
            pf.encoding = "UTF-8";
            pf.write(JSON.stringify(obj, null, 2));
            pf.close();
            return true;
        } catch (e) {
            return false;
        }
    }

    // ---- UI (kept identical to original) ----
    var win = (thisObj instanceof Panel) ? thisObj : new Window("palette", SCRIPT_NAME, undefined, { resizeable: true });
    win.orientation = "column";
    win.alignChildren = ["fill", "top"];
    win.spacing = 4;
    win.margins = [6, 6, 6, 6];

    if (!(thisObj instanceof Panel)) win.preferredSize = [480, 520];

    var header = win.add("group"); header.orientation = "column"; header.alignment = ["fill", "top"];
    var title = header.add("statictext", undefined, SCRIPT_NAME);
    title.graphics.font = ScriptUI.newFont("Arial", "BOLD", 12);
    var sub = header.add("statictext", undefined, "by antikvn");
    sub.graphics.font = ScriptUI.newFont("Arial", "REGULAR", 9);

    // Preset controls
    var presetGroup = win.add("group"); presetGroup.orientation = "row"; presetGroup.alignChildren = ["left", "center"];
    var presetDD = presetGroup.add("dropdownlist", undefined, []);
    presetDD.preferredSize.width = 100;
    var loadPresetBtn = presetGroup.add("button", undefined, "Ld"); loadPresetBtn.preferredSize.width = 30;
    var savePresetBtn = presetGroup.add("button", undefined, "Sv"); savePresetBtn.preferredSize.width = 30;
    var deletePresetBtn = presetGroup.add("button", undefined, "Del"); deletePresetBtn.preferredSize.width = 35;

    // Audio selection
    var audioLabel = win.add("statictext", undefined, "Audio Layer:");
    audioLabel.graphics.font = ScriptUI.newFont("Arial", "REGULAR", 9);
    var audioDropdown = win.add("dropdownlist", undefined, []);
    audioDropdown.alignment = ["fill", "top"];
    audioDropdown.preferredSize.height = 20;

    // Conversion button
    var convertBtn = win.add("button", undefined, "Convert Audio");
    convertBtn.alignment = ["fill", "top"]; convertBtn.preferredSize.height = 22;

    // Sensitivity & Smoothing Group
    var group1 = win.add("group"); group1.orientation = "row"; group1.alignChildren = ["fill", "center"]; group1.spacing = 2;
    var sensGroup = group1.add("group"); sensGroup.orientation = "column"; sensGroup.spacing = 2;
    var sensLabel = sensGroup.add("statictext", undefined, "Sens"); sensLabel.graphics.font = ScriptUI.newFont("Arial", "REGULAR", 8);
    var sensDD = sensGroup.add("dropdownlist", undefined, ["Low", "Med", "Hi"]); sensDD.selection = 1; sensDD.preferredSize.height = 18;

    var smoothGroup = group1.add("group"); smoothGroup.orientation = "column"; smoothGroup.spacing = 2;
    var smoothLabel = smoothGroup.add("statictext", undefined, "Smooth"); smoothLabel.graphics.font = ScriptUI.newFont("Arial", "REGULAR", 8);
    var smoothDD = smoothGroup.add("dropdownlist", undefined, ["None", "Lt", "Med", "Str"]); smoothDD.selection = 2; smoothDD.preferredSize.height = 18;

    var gapGroup = group1.add("group"); gapGroup.orientation = "column"; gapGroup.spacing = 2;
    var gapLabel = gapGroup.add("statictext", undefined, "Gap"); gapLabel.graphics.font = ScriptUI.newFont("Arial", "REGULAR", 8);
    var gapDD = gapGroup.add("dropdownlist", undefined, ["VFst", "Fst", "Norm", "Slow", "VSlo"]); gapDD.selection = 2; gapDD.preferredSize.height = 18;

    // BPM snapping controls
    var bpmGroup = win.add("panel", undefined, "BPM Snap");
    bpmGroup.orientation = "column"; bpmGroup.alignChildren = ["fill", "top"]; bpmGroup.margins = [5, 5, 5, 5]; bpmGroup.spacing = 2;
    var snapCheckbox = bpmGroup.add("checkbox", undefined, "Enable");
    var autoBpmBtn = bpmGroup.add("button", undefined, "Auto-Detect"); autoBpmBtn.alignment = ["fill", "top"]; autoBpmBtn.preferredSize.height = 20;
    var manualBpmGroup = bpmGroup.add("group"); manualBpmGroup.orientation = "row"; manualBpmGroup.spacing = 2;
    var bpmLabel = manualBpmGroup.add("statictext", undefined, "BPM:"); bpmLabel.graphics.font = ScriptUI.newFont("Arial", "REGULAR", 9);
    var manualBpmInput = manualBpmGroup.add("edittext", undefined, "120"); manualBpmInput.characters = 5; manualBpmInput.preferredSize.height = 18;
    var snapStrengthGroup = bpmGroup.add("group"); snapStrengthGroup.orientation = "row"; snapStrengthGroup.spacing = 2;
    var strengthLabel = snapStrengthGroup.add("statictext", undefined, "Strength:"); strengthLabel.graphics.font = ScriptUI.newFont("Arial", "REGULAR", 9);
    var snapStrengthDD = snapStrengthGroup.add("dropdownlist", undefined, ["Weak", "Med", "Strong"]); snapStrengthDD.selection = 1; snapStrengthDD.preferredSize.height = 18;

    // Marker options
    var markerPanel = win.add("panel", undefined, "Markers");
    markerPanel.orientation = "column"; markerPanel.alignChildren = ["left", "top"]; markerPanel.margins = [5,5,5,5]; markerPanel.spacing = 1;
    var tierStrong = markerPanel.add("checkbox", undefined, "STRONG beats"); tierStrong.value = true;
    var tierWeak = markerPanel.add("checkbox", undefined, "WEAK beats"); tierWeak.value = true;
    var tierSub = markerPanel.add("checkbox", undefined, "SUB-BEATS (½, ¼)");

    // Color selection
    var colorGroup = markerPanel.add("group"); colorGroup.orientation = "row"; colorGroup.alignChildren = ["left","center"]; colorGroup.spacing = 2;
    var colorLabel = colorGroup.add("statictext", undefined, "Color:"); colorLabel.graphics.font = ScriptUI.newFont("Arial", "REGULAR", 9);
    var colorDD = colorGroup.add("dropdownlist", undefined, [
        "Red","Yellow","Aqua","Pink","Lavender","Peach","Sea Foam","Blue","Green","Purple","Magenta","Sky","Tan","Forest","Cyan","Sand"
    ]);
    colorDD.selection = 0; colorDD.preferredSize.height = 18;

    // Progress bar
    var progressBar = win.add("progressbar", undefined, 0, 100); progressBar.alignment = ["fill", "top"]; progressBar.preferredSize.height = 3;

    // Generate + Remove buttons
    var btnGroup = win.add("group"); btnGroup.orientation = "row"; btnGroup.alignChildren = ["fill","center"]; btnGroup.spacing = 4;
    var generateBtn = btnGroup.add("button", undefined, "Generate"); generateBtn.preferredSize.height = 24;
    var removeBtn = btnGroup.add("button", undefined, "Remove"); removeBtn.preferredSize.height = 24;

    // Status message
    var status = win.add("statictext", undefined, "", {multiline: true}); status.alignment = ["fill", "top"]; status.minimumSize = [100,12];
    status.graphics.font = ScriptUI.newFont("Arial", "REGULAR", 8);

    // ---- Internal state ----
    var comp = null;
    var lastUpdateTime = 0;
    function uiUpdateGuard(force) {
        var now = new Date().getTime();
        if (force || (now - lastUpdateTime) > 300) {
            try { win.update(); } catch (e) {}
            lastUpdateTime = now;
        }
    }

    function showProgress(perc, msg, skipImmediateUpdate) {
        try {
            progressBar.value = clamp(parseInt(perc,10) || 0, 0, 100);
            setStatus(msg || "");
            if (!skipImmediateUpdate) uiUpdateGuard(true);
            else uiUpdateGuard(false);
        } catch (e) {}
    }

    // ---- Audio layer discovery ----
    function refreshAudioLayers() {
        try {
            audioDropdown.removeAll();
        } catch (e) { /* ignore */ }

        var items = [];
        try {
            if (app.project && app.project.activeItem && (app.project.activeItem instanceof CompItem)) {
                comp = app.project.activeItem;
                for (var i = 1; i <= comp.numLayers; i++) {
                    try {
                        var layer = comp.layer(i);
                        var hasAmp = false;
                        if (layer.name.indexOf("Audio Amplitude") !== -1) hasAmp = true;
                        else {
                            var effects = layer.property("ADBE Effect Parade");
                            if (effects) {
                                if (layer.effect("Both Channels") || layer.effect("Left Channel") || layer.effect("Right Channel")) {
                                    hasAmp = true;
                                }
                            }
                        }
                        if (hasAmp) items.push(layer.name);
                    } catch (e) { /* ignore layer errors */ }
                }
            }
        } catch (e) { /* ignore project errors */ }

        if (items.length === 0) {
            audioDropdown.add("item", "No audio amplitude layers found");
            audioDropdown.selection = 0;
        } else {
            for (var j=0;j<items.length;j++) audioDropdown.add("item", items[j]);
            audioDropdown.selection = 0;
        }
    }

    function getAmplitudeSlider(layer) {
        try {
            if (!layer) return null;
            if (layer.effect("Both Channels")) return layer.effect("Both Channels")("Slider");
            if (layer.effect("Left Channel")) return layer.effect("Left Channel")("Slider");
            if (layer.effect("Right Channel")) return layer.effect("Right Channel")("Slider");
        } catch (e) { }
        return null;
    }

    // ---- Signal processing helpers ----
    function buildKernel(index) {
        // kernels identical to previous behavior
        var kernels = [
            [1],
            [0.25, 0.5, 0.25],
            [0.1, 0.2, 0.4, 0.2, 0.1],
            [0.05,0.1,0.15,0.2,0.2,0.15,0.1,0.05]
        ];
        return kernels[ clamp(index|0, 0, kernels.length-1 ) ];
    }

    function applySmoothing(values, kernel) {
        // optimized convolution with bounds checks
        var n = values.length;
        if (n === 0) return [];
        var klen = kernel.length;
        var half = Math.floor(klen/2);
        var out = new Array(n);
        var halfway = Math.floor(n/2);

        // Pre-normalize kernel to ensure sum == 1 (guard against floating imprecision)
        var ksum = 0; for (var ka=0; ka<klen; ka++) ksum += kernel[ka];
        if (ksum === 0) ksum = 1;
        var knorm = new Array(klen);
        for (var kb=0; kb<klen; kb++) knorm[kb] = kernel[kb] / ksum;

        for (var i=0; i<n; i++) {
            if (i === halfway) showProgress(12, "Smoothing...", true);
            var s = 0, w = 0;
            var start = Math.max(0, i - half);
            var end = Math.min(n-1, i + (klen-half-1));
            for (var j=start; j<=end; j++) {
                var kidx = j - i + half;
                var kk = knorm[kidx] || 0;
                s += values[j] * kk;
                w += kk;
            }
            out[i] = (w > 0) ? (s / w) : values[i];
        }
        return out;
    }

    function detectPeaks(times, values, threshold, minTimeDist, sensitivity) {
        var peaks = [];
        if (!times || !values || times.length !== values.length) return peaks;
        var n = values.length;
        if (n < 3) return peaks;
        var lastTime = -1e9;
        var halfway = Math.floor(n/2);
        // sensitivity mapping: 0->High threshold multiplier, 2->Low
        var strengthThreshold = (sensitivity === 2) ? 1.0 : (sensitivity === 1) ? 1.1 : 1.2;

        // We start from 2..n-3 to reuse neighbors check like original
        for (var i = 2; i < n - 2; i++) {
            if (i === halfway) showProgress(30, "Finding peaks...", true);
            var v = values[i];
            if (!(v > threshold)) continue;
            // local max check
            if (!(v > values[i-1] && v >= values[i+1])) continue;
            var t = times[i];
            if ((t - lastTime) < minTimeDist) continue;
            var strength = v / threshold;
            if (strength >= strengthThreshold) {
                peaks.push({ time: t, strength: strength });
                lastTime = t;
            }
        }
        return peaks;
    }

    function estimateBPM(times) {
        if (!times || times.length < 2) return null;
        // compute diffs but guard against huge arrays by sampling if needed
        var n = times.length;
        var maxSamples = 1000;
        var idxStep = (n > maxSamples) ? Math.ceil(n / maxSamples) : 1;
        var prev = null;
        var diffs = [];
        for (var i = 0; i < n; i += idxStep) {
            var t = times[i];
            if (prev !== null) diffs.push(t - prev);
            prev = t;
        }
        if (diffs.length === 0) return null;
        var sum = 0;
        for (var j=0;j<diffs.length;j++) sum += diffs[j];
        var avg = sum / diffs.length;
        if (avg <= 0) return null;
        var bpm = 60.0 / avg;
        // clamp to a reasonable BPM range
        var bpmClamped = clamp(bpm, 20, 400);

        // --- Brazilian Phonk prioritization ---
        // Phonk often sits 120-160 BPM (sometimes half-time feel). If the detected BPM falls
        // outside that range, check double/half interpretations and pick the one closer to 120-160.
        try {
            var lowTarget = 120, highTarget = 160;
            if (bpmClamped < lowTarget || bpmClamped > highTarget) {
                var candidates = [bpmClamped, bpmClamped*2, bpmClamped/2];
                var best = candidates[0];
                var bestDist = Math.min(Math.abs(candidates[0]-((lowTarget+highTarget)/2)), Math.abs(candidates[0]-((lowTarget+highTarget)/2)));
                for (var ci=1; ci<candidates.length; ci++) {
                    var c = clamp(candidates[ci], 20, 400);
                    var dist = Math.abs(c - ((lowTarget+highTarget)/2));
                    if (dist < bestDist) { bestDist = dist; best = c; }
                }
                bpmClamped = best;
            }
        } catch (e) { /* ignore prioritization failures */ }

        return bpmClamped;
    }

    function snapToGrid(time, bpm, strengthIndex) {
        if (!bpm || bpm <= 0) return time;
        var beatDuration = 60.0 / bpm;
        var grid = time / beatDuration;
        var snapped = Math.round(grid);
        var str = strengthIndex|0;
        if (str <= 0) { // weak
            return time + (snapped - grid) * beatDuration * 0.5;
        } else if (str === 1) { // medium
            return time + (snapped - grid) * beatDuration * 0.8;
        } else { // strong
            return snapped * beatDuration;
        }
    }

    // ---- Marker creation/removal ----
    function createMarkers(peaks, bpm, doSnap) {
        if (!comp || !(comp instanceof CompItem)) {
            safeAlert("No active composition to add markers.");
            return;
        }
        if (!peaks || peaks.length === 0) {
            safeAlert("No peaks to create markers.");
            return;
        }

        try {
            app.beginUndoGroup("Auto Beat Marker Pro");

            var markerProp = comp.markerProperty;
            if (!markerProp) {
                safeAlert("Composition markers unsupported.");
                return;
            }

            var colorIndex = (colorDD.selection) ? colorDD.selection.index : 0;
            var snapStrength = (snapStrengthDD.selection) ? snapStrengthDD.selection.index : 1;
            var useStrong = !!tierStrong.value;
            var useWeak = !!tierWeak.value;
            var useSub = !!tierSub.value;

            var total = peaks.length;
            var halfway = Math.floor(total/2);

            // create keys in single pass
            for (var i=0;i<total;i++) {
                if (i === halfway) showProgress(70, "Creating markers...", true);
                var p = peaks[i];
                var t = p.time;
                if (doSnap && bpm) {
                    t = snapToGrid(t, bpm, snapStrength);
                }
                var label = "Beat";
                var pStrength = (typeof p.strength === "number") ? p.strength : 1.0;
                if (useStrong && pStrength >= 1.5) label = "Strong Beat";
                else if (useWeak && pStrength >= 1.2) label = "Weak Beat";
                else if (useSub) label = "Sub-Beat";

                var m = new MarkerValue(label);
                m.comment = "Strength: " + Number(pStrength).toFixed(2) + " (auto)";
                m.label = colorIndex;
                try {
                    markerProp.setValueAtTime(t, m);
                } catch (e) {
                    // If marker fails at a particular time, skip that time but continue
                }
            }
        } catch (e) {
            // try to gracefully end undo group
        } finally {
            try { app.endUndoGroup(); } catch (e) {}
        }
    }

    function removeAutoMarkers() {
        if (!comp || !(comp instanceof CompItem)) {
            safeAlert("No active composition.");
            return;
        }
        try {
            app.beginUndoGroup("Remove Auto Beat Markers");
            var mp = comp.markerProperty;
            if (!mp) {
                safeAlert("No composition marker property found.");
                return;
            }
            // collect indices to remove (iterate backwards for safe removal)
            var toRemove = [];
            var n = mp.numKeys || 0;
            for (var i = 1; i <= n; i++) {
                try {
                    var mv = mp.keyValue(i);
                    if (mv && mv.comment && (mv.comment.indexOf("Strength:") !== -1 || mv.comment.indexOf("(auto)") !== -1)) {
                        toRemove.push(i);
                    }
                } catch (e) { /* ignore */ }
            }
            for (var j = toRemove.length - 1; j >= 0; j--) {
                try { mp.removeKey(toRemove[j]); } catch (e) {}
            }
            setStatus("Removed " + toRemove.length + " auto-generated markers.");
        } catch (e) {
            safeAlert("Failed to remove markers: " + e.toString());
        } finally {
            try { app.endUndoGroup(); } catch (e) {}
        }
    }

    // ---- Main generator ----
    function generateBeatMarkers() {
        refreshAudioLayers(); // ensure comp and audio list are up-to-date
        if (!comp || !(comp instanceof CompItem)) {
            safeAlert("No active composition!");
            return;
        }
        if (!audioDropdown.selection || !audioDropdown.selection.text) {
            safeAlert("Select an audio amplitude layer first.");
            return;
        }

        var selectedLayerName = audioDropdown.selection.text;
        var layer = null;
        try {
            // try to fetch by name - robust to duplicate names (takes first match)
            for (var i = 1; i <= comp.numLayers; i++) {
                try {
                    var l = comp.layer(i);
                    if (l && l.name === selectedLayerName) { layer = l; break; }
                } catch (e) {}
            }
            if (!layer) {
                // fallback: try direct layer lookup (if name unique)
                try { layer = comp.layer(selectedLayerName); } catch (e) { layer = null; }
            }
        } catch (e) { layer = null; }

        if (!layer) {
            safeAlert("Selected audio layer not found in current comp.");
            return;
        }

        var slider = getAmplitudeSlider(layer);
        if (!slider || slider.numKeys < 2) {
            safeAlert("Audio amplitude keyframes missing. Use 'Convert Audio to Keyframes'.");
            return;
        }

        var numKeys = slider.numKeys;
        if (numKeys <= 0) {
            safeAlert("No keyframes on the amplitude slider.");
            return;
        }
        if (numKeys > MAX_KEYFRAMES) {
            var cont = confirm("Warning: " + numKeys + " keyframes detected. This can be slow. Continue?");
            if (!cont) return;
        }

        showProgress(1, "Reading keyframes...");
        // fast bulk read into arrays
        var times = new Array(numKeys);
        var values = new Array(numKeys);
        try {
            for (var k = 0; k < numKeys; k++) {
                times[k] = slider.keyTime(k+1);
                // protect against getter errors
                try { values[k] = parseFloat(slider.keyValue(k+1)); } catch (e) { values[k] = 0; }
            }
        } catch (e) {
            safeAlert("Failed reading keyframes: " + e.toString());
            showProgress(0, "");
            return;
        }
        showProgress(5, "Processing...");

        // smoothing
        var kernel = buildKernel(smoothDD.selection ? smoothDD.selection.index : 2);
        var smoothed = applySmoothing(values, kernel);

        showProgress(20, "Calculating threshold...");
        // threshold: based on sorted values (sample if very large)
        var sortedValues = smoothed.slice(0); // copy
        var sampleLimit = 8000;
        if (sortedValues.length > sampleLimit) {
            // simple sampling to avoid massive sort cost
            var sample = [];
            var step = Math.max(1, Math.floor(sortedValues.length / sampleLimit));
            for (var s = 0; s < sortedValues.length; s += step) sample.push(sortedValues[s]);
            sample.sort(function(a,b){return a-b;});
            sortedValues = sample;
        } else {
            sortedValues.sort(function(a,b){return a-b;});
        }

        var sensIndex = sensDD.selection ? sensDD.selection.index : 1;
        var threshIdx = Math.floor(sortedValues.length * (sensIndex === 0 ? 0.60 : sensIndex === 1 ? 0.75 : 0.90));
        threshIdx = clamp(threshIdx, 0, sortedValues.length-1);
        var threshold = (sortedValues.length > 0) ? sortedValues[threshIdx] : 0;
        // avoid zero threshold
        if (!threshold || threshold <= 0) threshold = 1e-6;

        // Minimum gap in frames -> seconds
        var minGaps = [2, 4, 6, 8, 12];
        var minFrames = minGaps[ clamp(gapDD.selection ? gapDD.selection.index : 2, 0, minGaps.length-1) ];
        var minTime = minFrames * comp.frameDuration;

        // ------------------------------------------------------------
        // Brazilian Phonk-specific detection enhancements:
        // 1) Try to detect explicit low/high sliders on the layer (users sometimes provide these).
        // 2) If explicit bands are not available, synthesize low/high proxies from the single amplitude
        //    by using multi-window smoothing and transient extraction:
        //    - lowBand: heavy smoothing (captures 808 sub-bass energy; longer envelope)
        //    - highBand: residual between raw and long-window smoothing (captures sharp transients, hi-hats)
        // 3) Use separate thresholds and minTime distances for low (kicks) and high (hi-hats).
        // 4) Merge peak lists with duplicate suppression and weight strengths so strong 808s dominate.
        // ------------------------------------------------------------

        // Helper to check for explicit frequency-band sliders (common in custom rigs)
        function findBandSlider(layerObj, names) {
            try {
                var effects = layerObj.property("ADBE Effect Parade");
                if (!effects) return null;
                for (var ni=0; ni<names.length; ni++) {
                    var nm = names[ni];
                    try {
                        if (layerObj.effect(nm) && layerObj.effect(nm)("Slider")) return layerObj.effect(nm)("Slider");
                    } catch (e) {}
                }
            } catch (e) {}
            return null;
        }

        // If user has added band-specific amplitude layers (e.g., Bass, Low, High, Hats), prefer them
        var explicitLowSlider = findBandSlider(layer, ["Bass", "LowFreq", "Low", "Sub", "Kick"]);
        var explicitHighSlider = findBandSlider(layer, ["Highs", "Hi", "Hats", "Cymbals", "Top"]);

        var lowValues = null;
        var highValues = null;

        if (explicitLowSlider && explicitHighSlider) {
            // Read explicit band keyframes (fast read)
            try {
                var lowKeys = explicitLowSlider.numKeys;
                var highKeys = explicitHighSlider.numKeys;
                // If counts match main slider, sample them; otherwise resample to times[] by interpolation fallback
                if (lowKeys === numKeys && highKeys === numKeys) {
                    lowValues = new Array(numKeys);
                    highValues = new Array(numKeys);
                    for (var ii = 0; ii < numKeys; ii++) {
                        try { lowValues[ii] = parseFloat(explicitLowSlider.keyValue(ii+1)); } catch (e) { lowValues[ii] = 0; }
                        try { highValues[ii] = parseFloat(explicitHighSlider.keyValue(ii+1)); } catch (e) { highValues[ii] = 0; }
                    }
                } else {
                    // fallback: use nearest-in-time sampling for each main time entry
                    lowValues = new Array(numKeys);
                    highValues = new Array(numKeys);
                    for (var ti=0; ti<times.length; ti++) {
                        var t = times[ti];
                        try { lowValues[ti] = explicitLowSlider.valueAtTime(t, false); } catch (e) { lowValues[ti] = 0; }
                        try { highValues[ti] = explicitHighSlider.valueAtTime(t, false); } catch (e) { highValues[ti] = 0; }
                    }
                }
            } catch (e) {
                lowValues = null; highValues = null;
            }
        }

        // If not present, synthesize proxies
        if (!lowValues || !highValues) {
            // Make a long-window smoothing to capture low/sub energy
            // Use a larger kernel for low smoothing than UI-specified smoothing to bias toward sub-bass energy.
            var longKernel = [0.01,0.02,0.05,0.1,0.64,0.1,0.05,0.02,0.01]; // large smoothing kernel (approx low-pass)
            var longSmoothed = applySmoothing(values, longKernel);

            // lowValues approximates sustained low-end energy (808s), good for kick detection
            lowValues = longSmoothed;

            // highValues approximates sharp transients: subtract long envelope from raw to produce high-pass-like residual
            highValues = new Array(values.length);
            for (var hi=0; hi<values.length; hi++) {
                highValues[hi] = values[hi] - longSmoothed[hi];
                // rectify to positive domain (we're interested in transient magnitudes)
                if (highValues[hi] < 0) highValues[hi] = 0;
            }

            // Also apply a light smoothing to the high residual to reduce single-sample noise
            var smallKernel = [0.25,0.5,0.25];
            highValues = applySmoothing(highValues, smallKernel);

            // Additional phonk-specific tweak:
            // Hi-hats often occur in double/triple subdivisions; allow detection sensitivity to be higher for highValues.
            // Low (808) hits can be smeared; using longSmoothed helps capture the slow envelope.
        }

        // Adaptive thresholds for each band: using local percentile rather than single global value can better adapt
        function computeAdaptiveThreshold(arr, sensitivity, baseFactor) {
            // baseFactor multiplies percentile to get threshold (tweak for hi/low)
            try {
                var copy = arr.slice(0);
                if (copy.length > 2000) {
                    // coarse sample for performance
                    var samp = [];
                    var st = Math.floor(copy.length / 2000);
                    for (var s=0;s<copy.length;s+=st) samp.push(copy[s]);
                    copy = samp;
                }
                copy.sort(function(a,b){return a-b;});
                var p = Math.floor(copy.length * (sensitivity === 0 ? 0.60 : sensitivity === 1 ? 0.75 : 0.90));
                p = clamp(p, 0, copy.length-1);
                var val = copy[p] || 0;
                // ensure not zero
                if (!val || val <= 0) val = 1e-6;
                return val * baseFactor;
            } catch (e) {
                return 1e-6;
            }
        }

        // Determine thresholds:
        // - lowThreshold favors slightly higher baseline (808 often very strong)
        // - highThreshold uses a lower baseFactor because hi-hat transients are shorter but can be lower amplitude after residual extraction
        var lowBaseFactor = (sensIndex === 2) ? 0.9 : (sensIndex === 1) ? 1.1 : 1.3;
        var highBaseFactor = (sensIndex === 2) ? 0.6 : (sensIndex === 1) ? 0.8 : 1.0;

        var lowThreshold = computeAdaptiveThreshold(lowValues, sensIndex, lowBaseFactor);
        var highThreshold = computeAdaptiveThreshold(highValues, sensIndex, highBaseFactor);

        // Min time distances: keep standard minTime for low (kicks), but allow much smaller minTime for high (hats)
        var minTimeLow = Math.max(minTime, 0.03); // ensure at least ~30ms between low peaks (guards against spurious double hits)
        var minTimeHigh = Math.max(comp.frameDuration * 1, 0.01); // allow very short spacing (10ms) to catch fast hi-hats

        // Run detection separately
        showProgress(35, "Detecting low-band peaks (kicks)...");
        var lowPeaks = detectPeaks(times, lowValues, lowThreshold, minTimeLow, sensIndex);

        showProgress(45, "Detecting high-band peaks (hats/transients)...");
        var highPeaks = detectPeaks(times, highValues, highThreshold, minTimeHigh, sensIndex);

        // Now combine peaks, preferring lowPeaks when they coincide (808 hits are primary).
        // Merge strategy:
        // - create union of times; if a high peak falls within small window of a low peak, boost strength of low peak instead of duplicating.
        var merged = [];
        var li = 0, hi = 0;
        // Convert to iterables sorted by time (they already are)
        // First, add all low peaks
        for (var lp=0; lp<lowPeaks.length; lp++) {
            merged.push({ time: lowPeaks[lp].time, strength: (lowPeaks[lp].strength || 1.0) * 1.2, source: "low" });
        }
        // Then add high peaks if they are not too close to a low peak (or treat them as separate sub-beats)
        var proximity = Math.max(minTime, 0.04); // 40ms proximity: if hi is within this of a low, consider it the same event
        for (var hp=0; hp<highPeaks.length; hp++) {
            var htime = highPeaks[hp].time;
            var tooClose = false;
            for (var m=0; m<merged.length; m++) {
                if (Math.abs(merged[m].time - htime) <= proximity) {
                    // enhance existing merged entry's strength slightly to reflect hi-hat presence on the same beat
                    merged[m].strength = merged[m].strength + (highPeaks[hp].strength || 0.8) * 0.25;
                    tooClose = true;
                    break;
                }
            }
            if (!tooClose) {
                // hi-hat isolated: keep but mark as lighter (sub-beat)
                merged.push({ time: htime, strength: (highPeaks[hp].strength || 0.8) * 0.9, source: "high" });
            }
        }

        // Sort merged by time
        merged.sort(function(a,b){ return a.time - b.time; });

        // Remove duplicates within a minimal merge window (minTime/2)
        var finalPeaks = [];
        var lastT = -1e9;
        var mergeWindow = Math.max(minTime * 0.5, comp.frameDuration * 0.5, 0.01);
        for (var mm=0; mm<merged.length; mm++) {
            var e = merged[mm];
            if ((e.time - lastT) < mergeWindow) {
                // Merge: keep the stronger entry
                if (finalPeaks.length > 0) {
                    var prev = finalPeaks[finalPeaks.length-1];
                    if (e.strength > prev.strength) {
                        finalPeaks[finalPeaks.length-1] = { time: e.time, strength: e.strength, source: e.source };
                        lastT = e.time;
                    } else {
                        // keep prev, ignore e
                    }
                } else {
                    finalPeaks.push({ time: e.time, strength: e.strength, source: e.source });
                    lastT = e.time;
                }
            } else {
                finalPeaks.push({ time: e.time, strength: e.strength, source: e.source });
                lastT = e.time;
            }
        }

        // Final strength normalization: ensure numeric strength exists
        for (var zp=0; zp<finalPeaks.length; zp++) {
            if (!finalPeaks[zp].strength || !isFinite(finalPeaks[zp].strength)) finalPeaks[zp].strength = 1.0;
        }

        var peaks = finalPeaks;

        // If detection returned nothing, fall back to original single-band detection behavior (backward compatibility)
        if ((!peaks || peaks.length === 0) && smoothed && smoothed.length > 0) {
            // original behavior fallback
            peaks = detectPeaks(times, smoothed, threshold, minTime, sensIndex);
        }

        if (!peaks || peaks.length === 0) {
            safeAlert("No peaks found – try reducing smoothing or increasing sensitivity (or convert audio to frequency bands for best results).");
            showProgress(0, "");
            return;
        }

        showProgress(50, "Estimating BPM...");
        var bpm = null;
        var doSnap = !!snapCheckbox.value;
        var manualBpm = parseFloat(manualBpmInput.text);
        if (doSnap && manualBpm > 0 && isFinite(manualBpm)) {
            bpm = clamp(manualBpm, 20, 400);
        } else {
            var peakTimes = [];
            for (var pi=0; pi<peaks.length; pi++) peakTimes.push(peaks[pi].time);
            bpm = estimateBPM(peakTimes);
        }

        showProgress(60, "Creating markers...");
        createMarkers(peaks, bpm, doSnap);

        showProgress(100, "Done: " + peaks.length + " markers. BPM = " + (bpm ? bpm.toFixed(2) : "N/A"));
        try { safeAlert("✅ Created " + peaks.length + " beat markers.\nEstimated BPM: " + (bpm ? bpm.toFixed(2) : "N/A")); } catch (e) {}
        showProgress(0, "");
    }

    // ---- Convert audio convenience ----
    function convertAudioToKeyframes() {
        if (!comp || !(comp instanceof CompItem)) {
            safeAlert("No active composition!");
            return;
        }
        var layer = null;
        try { layer = comp.selectedLayers[0]; } catch (e) { layer = null; }
        if (!layer || !(layer instanceof AVLayer) || !layer.source || (layer.source.mainSource instanceof FileSource) === false) {
            safeAlert("Select a valid audio layer in the comp.");
            return;
        }
        try {
            app.beginUndoGroup("Convert Audio to Keyframes");
            layer.selected = true;
            app.executeCommand(app.findMenuCommandId("Convert Audio to Keyframes"));
            app.endUndoGroup();
        } catch (e) {
            try { app.endUndoGroup(); } catch (ee) {}
            safeAlert("Failed to convert audio to keyframes: " + e.toString());
            return;
        }
        refreshAudioLayers();
        safeAlert("Audio converted – select the new amplitude layer in the dropdown.");
    }

    // ---- Preset UI wiring ----
    var presets = loadPresets();
    function refreshPresetList() {
        try {
            presetDD.removeAll();
            presetDD.add("item", "-- Select Preset --");
            for (var n in presets) {
                if (presets.hasOwnProperty(n)) presetDD.add("item", n);
            }
            presetDD.selection = 0;
        } catch (e) {}
    }
    refreshPresetList();

    loadPresetBtn.onClick = function () {
        try {
            if (presetDD.selection && (presetDD.selection.text in presets)) {
                var obj = presets[presetDD.selection.text];
                if (!obj) return;
                // safe apply with bounds checking
                try { sensDD.selection = sensDD.items[ clamp(obj.sens|0, 0, sensDD.items.length-1) ]; } catch (e) {}
                try { smoothDD.selection = smoothDD.items[ clamp(obj.smooth|0, 0, smoothDD.items.length-1) ]; } catch (e) {}
                try { gapDD.selection = gapDD.items[ clamp(obj.gap|0, 0, gapDD.items.length-1) ]; } catch (e) {}
                snapCheckbox.value = !!obj.snap;
                manualBpmInput.text = (obj.manualBpm !== undefined) ? String(obj.manualBpm) : manualBpmInput.text;
                try { snapStrengthDD.selection = snapStrengthDD.items[ clamp(obj.strength|0, 0, snapStrengthDD.items.length-1) ]; } catch (e) {}
                tierStrong.value = !!obj.strong; tierWeak.value = !!obj.weak; tierSub.value = !!obj.sub;
                try { colorDD.selection = colorDD.items[ clamp(obj.color|0, 0, colorDD.items.length-1) ]; } catch (e) {}
                setStatus("Preset '" + presetDD.selection.text + "' loaded.");
            }
        } catch (e) { setStatus("Failed to load preset."); }
    };

    savePresetBtn.onClick = function () {
        try {
            var name = prompt("Preset name:", "Default");
            if (!name) return;
            presets[name] = {
                sens: sensDD.selection ? sensDD.selection.index : 1,
                smooth: smoothDD.selection ? smoothDD.selection.index : 2,
                gap: gapDD.selection ? gapDD.selection.index : 2,
                snap: !!snapCheckbox.value,
                manualBpm: manualBpmInput.text,
                strength: snapStrengthDD.selection ? snapStrengthDD.selection.index : 1,
                strong: !!tierStrong.value,
                weak: !!tierWeak.value,
                sub: !!tierSub.value,
                color: colorDD.selection ? colorDD.selection.index : 0
            };
            if (savePresets(presets)) {
                refreshPresetList();
                setStatus("Saved preset '" + name + "'.");
            } else {
                setStatus("Preset saved to memory but failed to write file.");
            }
        } catch (e) { setStatus("Failed to save preset."); }
    };

    deletePresetBtn.onClick = function () {
        try {
            if (presetDD.selection && (presetDD.selection.text in presets)) {
                if (confirm("Delete preset '" + presetDD.selection.text + "'?")) {
                    delete presets[presetDD.selection.text];
                    if (savePresets(presets)) {
                        refreshPresetList();
                        setStatus("Deleted preset.");
                    } else {
                        setStatus("Deleted from memory but failed to save presets file.");
                    }
                }
            }
        } catch (e) { setStatus("Failed to delete preset."); }
    };

    // ---- Auto BPM detect button ----
    autoBpmBtn.onClick = function () {
        refreshAudioLayers();
        if (!audioDropdown.selection || !audioDropdown.selection.text) {
            safeAlert("Select audio layer first.");
            return;
        }
        var selName = audioDropdown.selection.text;
        var layer = null;
        for (var i=1;i<=comp.numLayers;i++) {
            try { if (comp.layer(i).name === selName) { layer = comp.layer(i); break; } } catch (e) {}
        }
        if (!layer) { safeAlert("Layer not found."); return; }
        var slider = getAmplitudeSlider(layer);
        if (!slider || slider.numKeys < 2) { safeAlert("Amplitude keyframes missing."); return; }
        var times = [], vals = [];
        for (var k=1; k<=slider.numKeys; k++) {
            times.push(slider.keyTime(k));
            try { vals.push(parseFloat(slider.keyValue(k))); } catch (e) { vals.push(0); }
        }
        var bpm = estimateBPM(times);
        if (bpm) {
            manualBpmInput.text = bpm.toFixed(2);
            setStatus("Estimated BPM: " + bpm.toFixed(2));
        } else {
            safeAlert("Could not estimate BPM.");
        }
    };

    // ---- Button wiring ----
    convertBtn.onClick = convertAudioToKeyframes;
    generateBtn.onClick = generateBeatMarkers;
    removeBtn.onClick = removeAutoMarkers;

    // ---- Show/refresh ----
    win.onShow = function () { refreshAudioLayers(); };
    win.onResizing = win.onResize = function () { this.layout.resize(); };

    if (win instanceof Window) { win.center(); win.show(); }
    else { win.layout.layout(true); }

})(this);
